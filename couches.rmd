---
title: "Coasting on Couches"
output: pdf_document #html_document
# runtime: shiny
author: Akshay *Regulagedda*, Kevin *Tan*, Wan Ling *Loh*, Zach *Zhang*, Xin Ying *Goh*
editor_options: 
  chunk_output_type: inline
---
# 0. Introduction
This document lists the exploratory data analysis, model build and analysis for *Coasting on Couches*, the term project for MGT 6203 Spring semester. Whilst the project document and slides/ presentation list a more human-readable version, this document combines some exposition with a lot of code to generate graphs, to put it simply.


## 0.1 Library Setup
The document will be shared as a Shiny app and in the raw RMd format. 

Please run the following chunk to ensure all the necessary libraries are installed/ present should you wish to execute the chunks at your end. (Idea taken from [this blogpost](https://vbaliga.github.io/verify-that-r-packages-are-installed-and-loaded/))

```{r}
packages<- c("dplyr", "stringr", "readr", "stargazer", "knitr", "DataExplorer", "ggplot2", "ggExtra", "psych", "PerformanceAnalytics", "corrplot", "mice", 
             "plotly", "geojsonio")#, "rjson") #add new libraries here

package.check <- lapply(
  packages,
  FUN = function(x)
  {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)
```
@XY, ZZ, WL: Please include this citation in our report: 
 Hlavac, Marek (2022). stargazer: Well-Formatted Regression and Summary Statistics Tables.
 R package version 5.2.3. https://CRAN.R-project.org/package=stargazer 
 
# 1. Loading Data

We had downloaded data from [InsideAirbnb.com](http://insideairbnb.com/get-the-data) to the data folder. This will be available on our [GitHub repo](https://github.com/metamutator/crispy-octo-waffle). 

The data is in four parts (each city has all five elements):
1. ``listing``: These are the actual Airbnb listings. The columns are defined [here](https://docs.google.com/spreadsheets/d/1iWCNJcSutYqpULSQHlNyGInUvHg2BoUGoNRIGa6Szc4/edit#gid=982310896). This is set of 74 variables pertaining to a specific listing.
2. ``review``: List of reviews per row in the ``listing`` table.
3. ``calendar``: Price of a particular listing on a particular date, along with min-max nights for hire
4. ``neighbourhoods``: List of neighbourhoods screened in the city
5. ``map``: GeoJson shapefile showing district boundaries.

## 1.1 Raw

We will read all the data into dataset variables. 
```{r echo=TRUE, message=TRUE, warning=TRUE}
#Singapore
listing.sin <- read.csv("./data/SIN_listings.csv")
reviews.sin <- read.csv("./data/SIN_reviews.csv")
calendar.sin <- read.csv("./data/SIN_calendar.csv")
neighbourhoods.sin <- read.csv("./data/SIN_neighbourhoods.csv")
map.sin <- geojson_read("./data/SIN_neighbourhoods.geojson")

#Taipei
listing.tpe <- read.csv("./data/TPE_listings.csv")
reviews.tpe <- read.csv("./data/TPE_reviews.csv")
calendar.tpe <- read.csv("./data/TPE_calendar.csv")
neighbourhoods.tpe <- read.csv("./data/TPE_neighbourhoods.csv")
map.tpe <- geojson_read("./data/TPE_neighbourhoods.geojson")

#Tokyo
listing.nrt <- read.csv("./data/NRT_listings.csv")
reviews.nrt <- read.csv("./data/NRT_reviews.csv")
calendar.nrt <- read.csv("./data/NRT_calendar.csv")
neighbourhoods.nrt <- read.csv("./data/NRT_neighbourhoods.csv")
map.nrt <- geojson_read("./data/NRT_neighbourhoods.geojson")

#Hong Kong
listing.hkg <- read.csv("./data/HKG_listings.csv")
reviews.hkg <- read.csv("./data/HKG_reviews.csv")
calendar.hkg <- read.csv("./data/HKG_calendar.csv")
neighbourhoods.hkg <- read.csv("./data/HKG_neighbourhoods.csv")
map.hkg <- geojson_read("./data/HKG_neighbourhoods.geojson")
```

## 1.2 Initial Data Analysis

### 1.2.1 Amenities

There's a column called amenities in the dataset that appears to list all the self-reported amenities in the listing as a single comma-separated list. Let's try to see this further. 

For instance, here's the longest list of amenities among Singapore listings.
```{r echo=TRUE, message=TRUE, warning=TRUE, paged.print=TRUE}
listing_amenities.sin <- listing.sin %>%
                      mutate(amenities = str_replace(amenities, "\\[","")) %>%
                      mutate(amenities = str_replace(amenities, "\\]","")) %>%
                      mutate(amenities = str_replace_all(amenities, "\"","")) %>%
                      mutate(amenities = str_replace_all(amenities, ", " ,",")) %>%
                      mutate(amenities_list = as.list(strsplit(amenities, ","))) %>%
                      mutate(no_of_am = lengths(amenities_list))
# listing_amenities.sin
max_amenities.sin <- listing_amenities.sin %>%
                      select(amenities, no_of_am) %>%
                      group_by() %>%
                     slice(which.max(no_of_am))
amenities_list_string <- as.list(strsplit(as.character(max_amenities.sin["amenities"]), ","))
amenities_list_string

#"Shampoo,Kitchen,Long term stays allowed,Washer,Smart lock,Hair dryer,Dryer,Wifi,Hot water,TV,Air conditioning,Smoke alarm,Fire extinguisher"
```

Apropos nothing, we will use the following amenities as dummy variables for price:
> "Shampoo,Kitchen,Long term stays allowed,Washer,Smart lock,Hair dryer,Dryer,Wifi,Hot water,TV,Air conditioning,Smoke alarm,Fire extinguisher"

### 1.2.2 Host Verifications

Similarly, let us also further analyse the column `host_verifications` to see if we can generate dummy variables from there as well.
```{r}
listing_host_verf.sin <- listing.sin %>%
                      mutate(host_verifications = str_replace(host_verifications, "\\[","")) %>%
                      mutate(host_verifications = str_replace(host_verifications, "\\]","")) %>%
                      mutate(host_verifications = str_replace_all(host_verifications, "\"","")) %>%
                      mutate(host_verifications = str_replace_all(host_verifications, ", " ,",")) %>%
                      mutate(host_verifications_list = as.list(strsplit(host_verifications, ","))) %>%
                      mutate(no_of_vf = lengths(host_verifications_list))

max_verf.sin <- listing_host_verf.sin %>%
                      select(host_verifications, no_of_vf) %>%
                      group_by() %>%
                     slice(which.max(no_of_vf))
host_verf_list_string <- as.list(strsplit(as.character(max_verf.sin["host_verifications"]), ","))
host_verf_list_string
```
Let's take this list to generate dummy variables.
> ['email', 'phone', 'facebook', 'reviews', 'manual_offline', 'jumio', 'offline_government_id', 'government_id', 'work_email']

Let's generalise these two bits for all cities.
```{r}

wrangle_amenities_hostvf <- function (listing)
{
  listing <- listing %>%
            mutate(amenities = str_replace(amenities, "\\[","")) %>%
            mutate(amenities = str_replace(amenities, "\\]","")) %>%
            mutate(amenities = str_replace_all(amenities, "\"","")) %>%
            mutate(amenities = str_replace_all(amenities, ", " ,",")) %>%
            mutate(amenities_list = as.list(strsplit(amenities, ","))) %>%
            mutate(no_of_am = lengths(amenities_list)) %>%
            mutate(host_verifications = str_replace(host_verifications, "\\[","")) %>%
            mutate(host_verifications = str_replace(host_verifications, "\\]","")) %>%
            mutate(host_verifications = str_replace_all(host_verifications, "\"","")) %>%
            mutate(host_verifications = str_replace_all(host_verifications, ", " ,",")) %>%
            mutate(host_verifications_list = as.list(strsplit(host_verifications, ","))) %>%
            mutate(no_of_vf = lengths(host_verifications_list))
}

listing.sin <- wrangle_amenities_hostvf(listing.sin)
listing.nrt <- wrangle_amenities_hostvf(listing.nrt)
listing.tpe <- wrangle_amenities_hostvf(listing.tpe)
listing.hkg <- wrangle_amenities_hostvf(listing.hkg)

```
### 1.2.3 Location Heatmaps

Let us also consider heatmaps of where the listings are in each city by neighbourhood. Admittedly, the InsideAirbnb website has a map for each city (here's one for [Taipei](http://insideairbnb.com/taipei)), but this does not show by district. At a later stage, this can be enhanced to see by variable or time-series.

```{r}
generate_choropleth_by_city <- function (listing, map, city_name)
{
  listings_by_neighbourhood <- listing %>%
                                count(neighbourhood_cleansed)
  g <- list (
    fitbounds = "locations",
    visible = FALSE
  )
  fig <- plot_ly()
  fig <- fig %>% add_trace(
    type="choropleth",
    geojson=map,
    locations=listings_by_neighbourhood$neighbourhood_cleansed,
    z=listings_by_neighbourhood$n,
    colorscale="Viridis",
    featureidkey="properties.neighbourhood"
  )
  
  fig <- fig %>% layout(
    geo = g
  )
  fig <- fig %>% colorbar(title = "No of listings")
  fig <- fig %>% layout(
    title = paste0("Listings by Neighbourhood - ", city_name)
  )
  fig
}

generate_choropleth_by_city(listing.sin, map.sin, "Singapore")
generate_choropleth_by_city(listing.nrt, map.nrt, "Tokyo")
generate_choropleth_by_city(listing.hkg, map.hkg, "Hong Kong")
generate_choropleth_by_city(listing.tpe, map.tpe, "Taipei")
```

## 1.3 Data Wrangling
This is a function that wrangles AirBnb data into an analysable chunk. Because we will be doing the same for multiple cities, we will do a function out of this. The function is based on top of code shared in the lecture for Module 2.

```{r}

wrangle_airbnb_dataset <- function (raw_listing_full)
{
  listing.raw <- raw_listing_full  %>% 
                select(price,number_of_reviews,beds,bathrooms,accommodates,reviews_per_month, property_type, room_type,review_scores_rating, neighbourhood_cleansed, neighbourhood_group_cleansed, latitude, longitude, amenities_list, host_verifications_list) %>% 
                rename(Reviews = number_of_reviews) %>% 
                rename(Beds = beds) %>% 
                rename(Baths = bathrooms) %>% 
                rename(Capacity = accommodates) %>% 
                rename(Monthly_Reviews = reviews_per_month) %>% 
                rename(Property_Type = property_type) %>% 
                rename(Room_Type = room_type) %>% 
                rename(Price = price) %>% 
                rename(Rating = review_scores_rating) %>%
                rename(Neighbourhood = neighbourhood_cleansed) %>%
                rename(Region = neighbourhood_group_cleansed)


  listing.raw <-  listing.raw %>% 
                mutate(Price = str_replace(Price, "[$]", "")) %>% 
                mutate(Price = str_replace(Price, "[,]", "")) %>% 
                mutate(Price = as.numeric(Price)) %>% 
                mutate(Room_Type = factor(Room_Type, levels = c("Shared room", "Private room", "Entire home/apt"))) %>% 
                mutate(Capacity_Sqr = Capacity * Capacity) %>% 
                mutate(Beds_Sqr = Beds * Beds) %>% 
                mutate(Baths_Sqr = Baths * Baths) %>% 
                mutate(ln_Price = log(1+Price)) %>% 
                mutate(ln_Beds = log(1+Beds)) %>%
                mutate(ln_Baths = log(1+Baths)) %>% 
                mutate(ln_Capacity = log(1+Capacity)) %>% 
                mutate(ln_Rating = log(1+Rating)) %>% 
                mutate(Shared_ind = ifelse(Room_Type == "Shared room",1,0)) %>% 
                mutate(House_ind = ifelse(Room_Type == "Entire home/apt",1,0)) %>% 
                mutate(Private_ind = ifelse(Room_Type == "Private room",1,0)) %>% 
                mutate(Capacity_x_Shared_ind = Shared_ind * Capacity) %>% 
                mutate(H_Cap = House_ind * Capacity) %>% 
                mutate(P_Cap = Private_ind * Capacity) %>% 
                mutate(ln_Capacity_x_Shared_ind = Shared_ind * ln_Capacity) %>% 
                mutate(ln_Capacity_x_House_ind = House_ind * ln_Capacity) %>% 
                mutate(ln_Capacity_x_Private_ind = Private_ind * ln_Capacity)

  return(listing.raw)
}

sin_listing.clean <- wrangle_airbnb_dataset(sin_listing)
head(sin_listing.clean)
```

```{r}
# if (!require(DataExplorer)) install.packages("DataExplorer")
# library(DataExplorer)

plot_str(sin_listing, type="r")
introduce(sin_listing)
plot_intro(sin_listing)
plot_missing(sin_listing)
plot_bar(sin_listing)
```

```{r}
plot_str(sin_listing.clean, type="r")
introduce(sin_listing.clean)
plot_intro(sin_listing.clean)
plot_missing(sin_listing.clean)
plot_bar(sin_listing.clean)
plot_bar(sin_listing.clean$Region)
plot_bar(sin_listing.clean$Neighbourhood)
pca_df <- na.omit(sin_listing.clean[, c("Price", "Room_Type", "Reviews", "Beds", "Capacity", "Monthly_Reviews")])
plot_qq(pca_df)
plot_prcomp(pca_df, variance_cap = 0.9, nrow = 2L, ncol=2L)

```
## 1.3 Outlier Detection
We will now check out outliers in our data for various parameters.

```{r}
generate_price_boxplot <- function (listing.clean, city, comparison_col = "")
{
  # png(file = "./graphs/boxplot.png")
  if (comparison_col == "")
  {
    boxplot(listing.clean$Price, data = listing.clean, ylab="Price", main=paste("Boxplot: Price for", city))
  }
  else
    boxplot(listing.clean$Price ~ listing.clean[[comparison_col]], data = listing.clean, ylab="Price", xlab=comparison_col, main=paste("Boxplot: Price vs", comparison_col, "for", city))
  # dev.off()
}

generate_price_boxplot(sin_listing.clean, "Singapore") #, sin_listing.clean$)
generate_price_boxplot(sin_listing.clean, "Singapore", "Room_Type") #, sin_listing.clean$)
generate_price_boxplot(sin_listing.clean, "Singapore", "Property_Type") #, sin_listing.clean$)
generate_price_boxplot(sin_listing.clean, "Singapore", "Capacity") #, sin_listing.clean$)
generate_price_boxplot(sin_listing.clean, "Singapore", "Beds") #, sin_listing.clean$)
generate_price_boxplot(sin_listing.clean, "Singapore", "Region") #, sin_listing.clean$)
generate_price_boxplot(sin_listing.clean, "Singapore", "Neighbourhood") #, sin_listing.clean$)
```
That was a visual analysis of outliers. Clearly, there are a few offerings that are very highly priced. Let's look at them in a bit more depth, especially those units with rental prices above $5000. 

```{r}
filter(sin_listing.clean, Price > 5000)
```

The listing for Southern Islands was curious enough for us to want to look it up on a map. 

![Southern Islands](./images/jurassicpark.png)

The given coordinates point to a location in Universal Studios Singapore, specifically the Jurassic Park Rapids Adventure ride. Now the price to USS is indeed expensive, and the Jurassic Park Rapids Adventure ride is a family favourite, but whether it is worth spending $8,900 to spend a night there may indeed be debatable. 

Realistically however, we suspect this is a listing from somewhere further south at Sentosa Cove, an exclusive community designed for high net-worth individuals. 

![Sentosa Cove](./images/sentosacove.png)

Which is a great lesson for analysing place data from Singapore. We are a very compact country, and a few decimal points' worth of difference in lat-long coordinates can indeed be the difference between a much loved amusement part ride or a high-end dwelling.

Let's filter rows for ``Price`` < 1000.
```{r}


sin_listing.clean <-sin_listing.clean %>%
              dplyr::filter(Price < 1000, !is.na(Price)) %>%
                dplyr::filter(Capacity < 9) %>%
                mutate(ln_Reviews = log(1+Reviews)) %>%
                mutate(ln_Monthly_Reviews = log(1+Monthly_Reviews))
sin_listing.clean
```

```{r}

lm0 <- lm(Price ~ Capacity, data = sin_listing.clean)
summary(lm0)
stargazer(lm0, type = "text")

ggplot(data = sin_listing.clean, aes(x = Capacity, y = Price)) + geom_point(aes(size=3)) +
scale_colour_hue(l=50) + # Use a slightly darker palette than normal
geom_smooth(method=lm,   # Add linear regression lines
           se=TRUE,    #  add shaded confidence region
           fullrange=TRUE) +
theme(axis.text.x = element_text(size=15), axis.text.y = element_text(size=15), 
        axis.title=element_text(size=15,face="bold"))
# vif(lm0)
```
```{r}

# The moderating effect of type of room. Lets model that.

lm1 <- lm(Price ~ Private_ind + House_ind, data = sin_listing.clean)
summary(lm1)
stargazer(lm1, type = "text")
```
```{r}
#Regression with Capacity and Dummy Variables for type of room:

lm2 <- lm(Price ~ Capacity + Private_ind + House_ind, data = sin_listing.clean)
summary(lm2)
stargazer(lm2, type = "text")
```

### 
```{r}
#Regression with Capacity,Dummy Variables and interaction between the two:
lm3 <- lm(Price ~ Capacity+Private_ind + House_ind+P_Cap+H_Cap, data = sin_listing.clean)
summary(lm3)
stargazer(lm3,type = "text")

```

### 2.4 Correlation Matrix
Let's find a correlation matrix for the various variables.

```{r}
sin_listing.clean_cap = select(sin_listing.clean, Price, Capacity, Private_ind, House_ind, P_Cap, H_Cap)
sin_listing.clean_cap
chart.Correlation(sin_listing.clean_cap, histogram=TRUE, pch=19)

sin_listing.clean_corr <- cor(sin_listing.clean_cap, use = "complete.obs")
head(round(sin_listing.clean_corr, 2))
corrplot(sin_listing.clean_corr)
```
```{r}
# la_listing <- la_listing %>%
#               dplyr::filter(Price < 5000 , !is.na(Beds), !is.na(Baths), !is.na(Price), !is.na(Rating)) %>%
#                 dplyr::filter(Capacity < 9) %>%
#                 mutate(ln_Reviews = log(1+Reviews)) %>%
#                 mutate(ln_Monthly_Reviews = log(1+Monthly_Reviews))

```
```{r}

# Remove Baths as Columns are all NA
# Remove ln_Price, Latitude/Longitude
sin_listing.clean_subset <- sin_listing.clean[,!names(sin_listing.clean) %in% c('ln_Price','Baths','Baths_Sqr','ln_Baths','latitude','longitude')]


# Imputing Missing Data
md.pattern(sin_listing.clean_subset)
imputed_Data <- mice(sin_listing.clean_subset, m=5, maxit = 50, method = 'pmm', seed = 100)
sin_listing.clean_imputed <- complete(imputed_Data,2)
md.pattern(sin_listing.clean_imputed)

#Define Smallest and Full Model 
minmod = lm(Price~1, data = sin_listing.clean_imputed)
fullmod = lm(Price~. , data = sin_listing.clean_imputed)

#Define Smallest and Full Model - Without Neighbourhood
#minmod = lm(Price~1, data = sin_listing.clean_imputed[,!names(sin_listing.clean_imputed) %in% c('Neighbourhood')])
#fullmod = lm(Price~. , data = sin_listing.clean_imputed[,!names(sin_listing.clean_imputed) %in% c('Neighbourhood')])


# Using BIC: k=log(nobs(fullmod), Using AIC: k=2
backward_regression = step(fullmod, scope = list(lower = minmod, upper = fullmod),direction = "backward", k=log(nobs(fullmod)), trace=F)
forward_regression = step(minmod, scope = list(lower = minmod, upper = fullmod),direction = "forward", k=log(nobs(fullmod)), trace=F)
summary(backward_regression)
summary(forward_regression)
```
